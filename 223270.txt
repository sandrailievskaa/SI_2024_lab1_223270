Одговори и објаснувања на лабс бр.1

4. За креирања на локален репозиториум ја користев наредбата: mkdir SI_2024_lab1_223270 која што служи за создавање на локално репо. и го додадов името на оддалеченото репо., потоа
за влез во новиот директориум користев: cd SI_2024_lab1_223270 и за иницијализација на git, git init.
5. За да се поврзе локалниот репозиториум со оддалечениот репозиториум на GitHub, го превземав URL на оддалечениот репозиториум на GitHub, т.е. : git remote add origin https://github.com/sandrailievskaa/SI_2024_lab1_223270,
за проверка на успешноста на ова користев git remote -v 
со што веќе ми овозможува да ги извршувам операции како праќање на код (push), примање на код (pull) и идните операции потребни за работа со кодот помеѓу локален и оддалечен репозиториум.
6. Откако ја креирав README.md датотеката и го внесов соодветниот текст во неа, ја зачував во директориумот на мојот локален репозиториум и потоа ја додадов со командата: git add README.md
Со оваа команда се додава README.md датотеката во индексот на Git, за да може да биде вклучена во следниот commit, следно е git commit -m "Initial commit", со ова направив commit со соодветната порака.
7. По превземањето на фајловите и нивното сместување во директориумот на локалниот репозиториум, извршив: git add SILab1Main.java SILab1_1.java SILab1_2.java за да ги додадам во индексот на Git,
потоа git commit -m "Add starter code", низ овие чекори ќе се додадат преземените фајлови во мојот локален Git репозиториум и ќе креират нов commit со пораката "Add starter code".
8. За синхронизација git fetch origin овде се превземаат сите промени од одалечениот репо., потоа се префрлем на друга гранка branch1 која сакам да ја синхронизирам git checkout branch1,
се спојуваат промените git merge origin/branch1, бидејќи нема конфликти git add . додаваме , и соодветна порака што сме направиле git commit -m "Sync with remote repository" и како последно,
git push origin branch1. За поправката на грешките, прво променив во фајлот SILab1_1 каде што променив со соодветно бараното и потоа со наредбата: git status за да проверам дали моите
промени се видливи, откако се уверив со соодветно покажаната и очекувана грешка бидејќи немам додадено на сцена, ја повикав командата: git commit -a -m "Fix filterOddLengthStrings method to filter strings with odd length",
истата постапка следеше и за барањето под б, со тоа што на крај го upload изработеното со git push origin branch1.
9. За да се префрлам на главната гранка користев, git checkout master а после со помош на наредбата git checkout -b bug1 креирав гранка која што ќе се разгранува од master, истото и за bug2.
10. git checkout bug1 -> префрлање кон гранка1 што ја креирав и со тоа можност за работење на неа, најразлични промени.
11. Го изменив условот во методот filterOddLengthStrings така што ги филтрирав стринговите со непарна должина, како што е барано if (el.length() % 2 != 0) и тоа го зачував.
Прво за проверка секогаш користам git status, за да знам што сум променила, потоа го додавам фајлот со git add SILab1_1.java и наредбата за commit со посакуваната порака 
git commit -m "Fix wrong condition in filterOddLengthStrings", на крај ги праќам промените git push origin bug1.
12. git checkout bug2 префрлање на гранката2.
13. Истиот начин за поправање на грешката беше и овде, само што промената во условот е if (el.length() >= minLength), додека пак командите користени во Git се исти потполно, освен пораката во commit.
14. git checkout bug1 повторно враќање на гранка1 (switch)
15. Најпрво ја додадов линијата код после for-loop после 16та линија, го зачував тоа и потоа: 
git add SILab1Main.java -> додавање на фајлот каде менував
git commit -m "Call method filterOddLengthStrings in main class" -> правње commit со порака
git push origin bug1 -> испраќање на промените
16. git checkout bug2, отварањето на гранката bug2 овозможува да се продолжи со работа и да прави промени врз проблемот што се разгледува на оваа гранка.
17. Правење на потребна промена во фајл
git add SILab1Main.java ->додавање на фајлот каде менував
git commit -m "Call method makeBigStringFrom in main class" ->правње commit со порака
git push origin bug2 ->испраќање на промените
18. Со ова ги синхронизирам локалните гранки со гранките на оддалечениот репозиториум. Локалниот репозиториум сега ќе биде ажуриран со најновите промени на секоја гранка.
git checkout branch1
git pull origin branch1

git checkout bug1
git pull origin bug1

git checkout bug2
git pull origin bug2
19. git checkout master - префлање на master
20. За спојување на гранката потребно е: git checkout master што претходно направив, па спојување на гранката bug1 во гранката master користејќи ја командата git merge.
Ова ќе ги спои заедно, претворајќи ги во едно. Во случај на конфликти, треба да се разрешат конфликтите пред да се продолжи. 
Ако нема конфликти како што е мојот случај, ќе бидат пренесени во резултатната гранка, во овој случај, master. (може да се види во продолжение)
Updating 57b6050..58d1582
Fast-forward
 SILab1Main.java | 1 +
 1 file changed, 1 insertion(+)
21. Синхронизирање
git checkout branch1
git pull origin branch1

git checkout bug1
git pull origin bug1

git checkout bug2
git pull origin bug2
22. За да се префрли на гранката bug2: git checkout bug2
23. <<<<<<< HEAD
    }
    filterOddLengthStrings System.out.println(SILab1_1.filterOddLengthStrings(list));
=======
    } makeBigStringFrom System.out.println(SILab1_2.makeBigStringFrom(list));
>>>>>>> 0106484 (Call method makeBigStringFrom in main class)
Како што може да се воочи, овде добив конфликт. Делот помеѓу <<<<<<< HEAD и ======= е промената од моменталната гранка (bug2). Делот помеѓу ======= и >>>>>>> е промената од гранката 
master. Се одлучив конфликтот да го разрешам со тоа што ќе оставам една од можностите, а тоа е кодот од гранка bug2 со што го отстранив соодветно непотребното. Промените ги зачував со
git add SILab1Main.java и потоа git rebase --continue, оваа команда ќе продолжи со ребејсањето и ќе заврши процесот, вклучувајќи ги промените во bug2 врз основата на master.
24. git checkout master 
25. git merge bug2 се врши спојување на гранката со master, има можност да се појават конфликти, но овде немаше.
26. git fetch origin
git pull origin branch1
git pull origin bug1
git pull origin bug2
Првата команда, git fetch origin, ќе ја преземе содржината на сите гранки од оддалечениот репозиториум, но не ќе ги примени промените врз мојата работна копија. Потоа,
со git pull origin за да ги примени промените од сите гранки врз тековната. Откако ќе ги извршите овие команди, сите гранки ќе бидат ажурирани со последните промени од оддалечениот репозиториум.
27. git push origin branch1
git push origin bug1
git push --force origin bug2
Првите две команди се стандардни операции за пристап до branch1 и bug1 гранки. За гранката bug2, користиме --force опцијата за да принудиме прифаќање на промените, 
бидејќи претходно сме извршиле преработка (rebase) врз таа гранка.
28. git log -> добивање на досегашни logovi,  додавање на датотеките  git add logs.txt INDEX.txt,  последниот комит git commit -m "Final commit"



